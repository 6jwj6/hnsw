from Compiler.library import *
from Compiler.types import *
from Compiler.oram import *
from Programs.Source.HeapQ import HeapQ

Q = HeapQ(max_size=100, # Defines value range [0, max_size-1] and heap capacity
          oram_type=OptimalORAM,
          int_type=sint,
           entry_size=(10, 6) # (priority_bits, value_bits) for HeapEntry
)
print_ln('-'*50+'Part 1'+'-'*50)
# # ---------------------------------------Part 1-----------------------------
# # 在你的循环之前，先清空或重新初始化 Q
# # ...

# 第一次插入 (value=100, 映射到地址 36)
Q.update(130, sint(200), sint(1))
# Q.update(100, sint(200), sint(1))      work same
print_ln("Inserted value 100 with prio 200")
print_ln('size = %s',Q.size.reveal())
# 第二次插入 (value=36, 也映射到地址 36，会覆盖上面的索引信息)
Q.update(36, sint(50), sint(1))
# Q.update(36, sint(50), sint(1))
print_ln("Inserted value 36 with prio 50")
print_ln('size = %s',Q.size.reveal())
# 现在堆里应该有 prio=200 和 prio=50 的两个元素
# 最小值应该是 50
entry = Q.pop(sint(1))
print_ln("Popped value is %s, prio is %s", entry[1].reveal(), entry[0].reveal())
print_ln('size = %s',Q.size.reveal())
# 应该会弹出 36, 50

# 现在再弹一次，应该弹出 100, 200
entry = Q.pop(sint(1))
print_ln("Popped value is %s, prio is %s", entry[1].reveal(), entry[0].reveal())
print_ln('size = %s',Q.size.reveal())

# 现在尝试删除 100
# 这个操作很可能会失败，或者产生意想不到的结果，因为它在 value_index 中的记录已经被 36 的插入给覆盖了！
Q.update(100, sint(-32), sint(1))
print_ln('size = %s',Q.size.reveal())
entry = Q.pop(sint(1))
print_ln("Tried to delete 100, but popped: %s", entry[0].reveal())
print_ln('size = %s',Q.size.reveal())

# --------------------------------------Part 2----------------------------------------------------
print_ln('-'*50+'Part 2'+'-'*50)
for i in range(10):
    op = sint.get_input_from(0)
    x = sint.get_input_from(0)
    x = x + 100
    pos = i + 200
    Q.update(pos, x, op==1)
    entry_Pop = Q.pop(op==0)
    entry_Top = Q.top(op==2)
    
    @if_((op==1).reveal())
    def _():
        print_ln('%s inserted at %s...', x.reveal(), pos)
        print_ln('size = %s',Q.size.reveal())

    @if_((op==0).reveal())
    def _():
        print_ln('%s poped...', entry_Pop[0].reveal())
        print_ln('size = %s',Q.size.reveal())

    @if_((op==2).reveal())
    def _():
        print_ln('%s is the top...', entry_Top[0].reveal())
        print_ln('size = %s',Q.size.reveal())

    over_size = Q.size > 3
    @if_(over_size.reveal())
    def _():
        ee = Q.pop(over_size)
        print_ln('size > 3, %s poped...', ee[0].reveal())
        print_ln('size = %s',Q.size.reveal())

    
    #print_ln('(大小，序号) = (%s,%s)', Q.top()[0].reveal(),Q.top()[1].reveal())