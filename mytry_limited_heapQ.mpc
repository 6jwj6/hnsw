from Compiler.library import *
from Compiler.types import *
from Compiler.oram import *
from Compiler.program import Program
from Programs.Source.HeapQ import *
N_VALUE_BITS = 6
HEAP_MAX_SIZE_AND_VALUE_RANGE = 2**N_VALUE_BITS 

NEG_INF_PRIO = sint(-(2**(N_VALUE_BITS - 1)))

print_ln("Initializing HeapQ with max_size/value_range = %s (%s bits for x)...", HEAP_MAX_SIZE_AND_VALUE_RANGE, N_VALUE_BITS)

Q = HeapQ(max_size=HEAP_MAX_SIZE_AND_VALUE_RANGE, # Defines value range [0, max_size-1] and heap capacity
          oram_type=OptimalORAM,
          int_type=sint,
          entry_size=(N_VALUE_BITS, N_VALUE_BITS) # (priority_bits, value_bits) for HeapEntry
)
print_ln('-'*50+'RESULT'+'-'*50)   


for i in range(20):
    op = sint.get_input_from(0)
    x = sint.get_input_from(0)
    Q.update(i, x, op==1)
    entry_pop = Q.pop(op==0)
    entry_top = Q.top(op==2)

    @if_((op==1).reveal())
    def _():
        print_ln('%s insert...', x.reveal())
    @if_((op==0).reveal())
    def _():
        print_ln('%s poped...', entry_pop[0].reveal())
    @if_((op==2).reveal())
    def _():
        print_ln('%s is the top...', entry_top[0].reveal())

    #print_ln('(大小，序号) = (%s,%s)', Q.top()[0].reveal(),Q.top()[1].reveal())