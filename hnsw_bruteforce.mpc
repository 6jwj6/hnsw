from Compiler.library import *
from Compiler.types import *
from Compiler.oram import *
from Programs.Source.HeapQ import MinHeapQ,MaxHeapQ
import time
from Compiler.mpc_math import *
# --- 全局常量和变量 ---
MINX = -1000
MAXX = 1000

D = 4  # 向量维度
M = 5  # 每个节点的最大连接数 (除第0层外)
MMAX0 = 2 * M  # 第0层的最大连接数
MMAX = M
N = 1000 # 数据点数量
EF_CONSTRUCTION = 5  # 构建索引时的搜索范围大小
K = 3  # K-NN搜索中的K值
# NlgN = N * (int)(math.log2(N))
# 数据和图结构

# node = [[] for _ in range(N + 1)]
node = sint.Tensor([N+1,D])


# HNSW 算法状态
L = 0  # 当前最高层数
EP = 1  # 入口点 (entry point) 的索引
nodecnt = 0  # 图中节点的总数 (跨所有层)
ML = 1 / math.log(M)

# def trysort():
#     Q = sint.Tensor([1000, 2])
#     for i in range(1000):
#         op = sint.get_input_from(1)
#         x = sint.get_input_from(1)
#         x = x + 100
#         pos = i + 130
#         Q[i] = (x, pos)
#     # Q.sort(key_indices = [1])
#     Q.sort()
#     print_ln('%s',Q.reveal_list())
#     s = Q.get_vector_by_indices(None, 1)
#     print_ln('lens = %s', len(s))
#     print_ln('%s', s.reveal())

# def tryoram():
#     x = OptimalORAM(size = 32, value_length = 4)
#     x.access(sint(1), (2,3,4,2), True)
#     va = x[1]
#     vv = va[2] # tuple [0,3]
#     print_ln('x[1][2] = %s',vv.reveal())
#     x.delete(1)
#     print_ln('%s', x[1][2].reveal())

# def tryheapq():
#     Q = MaxHeapQ(max_size=100)
    
#     print_ln('%s', Q.pop()[0].reveal())
#     print_ln('%s', Q.pop()[0].reveal())
#     print_ln('%s', Q.pop()[0].reveal())
#     print_ln('%s', Q.pop()[0].reveal())
#     print_ln('%s', Q.pop()[0].reveal())
#     for i in range(10):
#         op = sint.get_input_from(0)
#         x = sint.get_input_from(0)
#         x = x + 100
#         pos = i + 130
#         Q.update(pos, x, op==1)
    
#         entry_Pop = Q.pop(op==0)
#         entry_Top = Q.top(op==2)
        
#         @if_((op==1).reveal())
#         def _():
#             print_ln('%s inserted at %s...', x.reveal(), pos)
#             print_ln('size = %s',Q.size.reveal())

#         @if_((op==0).reveal())
#         def _():
#             print_ln('%s poped...', entry_Pop[0].reveal())
#             print_ln('size = %s',Q.size.reveal())

#         @if_((op==2).reveal())
#         def _():
#             print_ln('%s is the top...', entry_Top[0].reveal())
#             print_ln('size = %s',Q.size.reveal())

#         over_size = Q.size > 3
#         @if_(over_size.reveal())
#         def _():
#             ee = Q.pop(over_size)
#             print_ln('size > 3, %s poped...', ee[0].reveal())
#             print_ln('size = %s',Q.size.reveal())

#     print_ln('-'*50+'END'+'-'*50)

# def test():
#     a = OptimalORAM(size = 101, value_length = MMAX0+10)
#     a[1] = (3,4,5)
#     a[a[1][2]] = (3,3,4,5)
#     print_ln('aaa = %s', a[5][2].reveal())
#     print_ln('len = %s', len(a[1]))
#     for i in range(10):
#         tmp = sint.Array(100)
#         tmp.input_from(1)
#         print_ln('%s',type(tmp))
#         print_ln('%s',tmp.reveal_list())
#         # for _ in range(100):
#         #     print_ln('%s', tmp[_].reveal())
#         # a.access(i,[*tmp],True)
#         # a.access(i, tuplify([*tmp]), True)
#         # a[i] = tuplify([*tmp])
#         a[i] = [*tmp]
#         # print_ln('%s',[a[i][j].reveal() for j in range(D)])
#         print_ln('a[i][3] = %s',a[i][3].reveal())
#         a.delete(i)
#         print_ln('%s', a[i][2].reveal())

def distance_query_to_node(q_idx, node_idx):
    """计算一个查询点和一个主数据集节点之间的距离"""
    vec1 = querynode[q_idx]
    vec2 = node[node_idx]
    res = sint(0)
    for i in range(D):
        res = res + (vec1[i]-vec2[i]) * (vec1[i]-vec2[i])
    return res

def distance_node_to_node(idx1, idx2):
    """计算主数据集中两个节点之间的距离"""
    vec1 = node[idx1]
    vec2 = node[idx2]
    res = sint(0)
    for i in range(D):
        res = res + (vec1[i]-vec2[i]) * (vec1[i]-vec2[i])
    return res

    return

# --- 初始化和主程序 ---
def init():
    """从文件加载数据"""
    print_ln("开始读取数据...")
    tmp = sint.Array(D)
    for i in range(1, N + 1):
        tmp.input_from(1)
        node[i] = tmp
    print_ln("完成读取 data.txt")
    
    # 打印前3个节点以供验证 (这部分代码保持不变)
    if N >= 3:
        for i in range(1, 4):
            print_ln("节点 %s: %s", i, [node[i][j].reveal() for j in range(D)])


b_Q = MaxHeapQ(max_size = K + 2)
def bruteforce_for_query_heap(q_idx):
    """暴力搜索查询点 q_idx 的 K 个最近邻"""
    start_time = time.time()
    for i in range(1, N + 1):
        dist = distance_query_to_node(q_idx, i)
        b_Q.update(i, dist)
        b_Q.pop(b_Q.size > K)
    ret = [b_Q.pop()[1].reveal() for _ in range(K)]
    # ret.sort()
    end_time = time.time()
    duration_ms = (end_time - start_time) * 1000
    print_ln("\n暴力搜索结果:")
    print_ln('序号: %s',ret)
    # for r_idx in ret:
    #     dist = distance_query_to_node(q_idx, r_idx)
    #     print_ln("%s || %s", [node[r_idx][_].reveal() for _ in range(D)], dist.reveal())
    print_ln("查询耗时: %s ms", duration_ms)
    return ret

def bruteforce_for_query_sort(q_idx):
    """暴力搜索查询点 q_idx 的 K 个最近邻，用 sort"""
    start_time = time.time()
    sQ = sint.Tensor([N, 2])
    for i in range(1, N+1):
        dist = distance_query_to_node(q_idx, i)
        sQ[i - 1] = (i, dist)
    sQ.sort(key_indices = [1])
    sQ = sQ.get_vector_by_indices(None, 0)[:K:]
    end_time = time.time()
    duration_ms = (end_time - start_time) * 1000
    print_ln("\n暴力搜索结果:")
    print_ln('序号: %s', [_.reveal() for _ in sQ])
    print_ln("查询耗时: %s ms", duration_ms)
    return sQ
'''-------------------主程序-----------------------------'''
print_ln('-'*50+'RESULT'+'-'*50)
print_ln()
# tryheapq()
# trysort()
# test()
print_ln("*"*50)
print_ln("N (数据点数): %s", N)
print_ln("D (维度): %s", D)
print_ln("M (最大连接数): %s", M)
print_ln("mL (层级因子): %s", ML)
print_ln("K (近邻数): %s", K)
print_ln("efConstruction: %s", EF_CONSTRUCTION)
print_ln("*"*50)
init()

nq = 21
querynode = [] # 确保查询列表是空的
for i in range(nq):
    val = ((i - (nq - 1) / 2) * ((MAXX - MINX) / (nq - 1)))
    querynode.append([sint(int(val))] * D)

ave_recall = 0.0
for q_idx in range(9,11):
    # 现在的 q_idx 就是 querynode 列表的索引 (0, 1, 2...)
    print_ln("\n--------------------------------")
    print_ln("当前查询点 (索引 %s) 为 (%s)",q_idx,
                [querynode[q_idx][_].reveal() for _ in range(D)])
   
    # bruteforce_for_query_heap(q_idx)
    bruteforce_for_query_sort(q_idx)
   
print_ln('-'*50+'END'+'-'*50)