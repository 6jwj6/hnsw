from Compiler.library import *
from Compiler.types import *
from Compiler.oram import *
# from Programs.Source.HeapQ import MinHeapQ,MaxHeapQ
from Compiler.path_oblivious_heap import UniquePathObliviousHeap,UniquePOHToHeapQAdapter,PathObliviousHeap
import time
from Compiler.mpc_math import *
from Compiler.library import start_timer, stop_timer
# --- 全局常量和变量 ---
MINX = -1000
MAXX = 1000

D = 4  # 向量维度
M = 6  # 每个节点的最大连接数 (除第0层外)
MMAX0 = 2 * M  # 第0层的最大连接数
MMAX = M
N = 10000 # 数据点数量
EF_CONSTRUCTION = 10  # 构建索引时的搜索范围大小
K = 1  # K-NN搜索中的K值
# NlgN = N * (int)(math.log2(N))
# node = [[] for _ in range(N + 1)]
node = sint.Tensor([N+1,D])
querynode = None
# HNSW 算法状态
L = 0  # 当前最高层数
EP = 1  # 入口点 (entry point) 的索引
nodecnt = 0  # 图中节点的总数 (跨所有层)
ML = 1 / math.log(M)
nq = 21

def distance_query_to_node(q_idx, node_idx):
    """计算一个查询点和一个主数据集节点之间的距离"""
    vec1 = querynode[q_idx]
    vec2 = node[node_idx]
    delta = vec1 - vec2
    res = (delta * delta).sum()
    return res

def distance_node_to_node(idx1, idx2):
    """计算主数据集中两个节点之间的距离"""
    vec1 = node[idx1]
    vec2 = node[idx2]
    delta = vec1 - vec2
    res = (delta * delta).sum()
    return res

# --- 初始化和主程序 ---
def init():
    """从文件加载数据"""
    print_ln("开始读取数据...")
    tmp = sint.Array(D)
    @for_range_opt(1,N+1)
    def _(i):
        tmp.input_from(1)
        node[i] = tmp
    print_ln("完成读取 data.txt")
    
    # 打印前3个节点以供验证 (这部分代码保持不变)
    if N >= 3:
        for i in range(1, 4):
            print_ln("节点 %s: %s", i, [node[i][j].reveal() for j in range(D)])

def initquerynode(num, dim = D):
    print_ln("\n开始读入查询数据...")
    global querynode
    querynode = sint.Tensor([num + 1 , dim])
    tmp = sint.Array(D)
    @for_range_opt(1, num + 1)
    def _(i):
        tmp.input_from(0)
        querynode[i] = tmp
        # print_ln('%s', querynode[i].reveal())
    print_ln("----完成读入查询数据")

def bruteforce_for_query_sort(q_idx):
    ''' 可以改变计算距离的方式，得到更快的方法'''
    """暴力搜索查询点 q_idx 的 K 个最近邻，用 sort"""
    start_timer(timer_id = 333)
    sQ = sint.Tensor([N, 2])
    @for_range_opt(1, N+1)
    def _(i):
        dist = distance_query_to_node(q_idx, i)
        sQ[i - 1] = (i, dist)
    sQ.sort(key_indices = [1])
    sQ = sQ.get_vector_by_indices(None, 0)[:K:]
    stop_timer(timer_id = 333)
    print_ln("\n暴力搜索结果:")
    print_ln('序号: %s', [_.reveal() for _ in sQ])
    return sQ

'''-------------------主程序-----------------------------'''
print_ln('-'*50+'RESULT'+'-'*50)
print_ln()
print_ln("*"*50)
print_ln("N (数据点数): %s", N)
print_ln("D (维度): %s", D)
print_ln("M (最大连接数): %s", M)
print_ln("mL (层级因子): %s", ML)
print_ln("K (近邻数): %s", K)
print_ln("efConstruction: %s", EF_CONSTRUCTION)
print_ln("*"*50)
init()

nq = 21
initquerynode(nq)

@for_range(nq)
def _(q_idx):
    print_ln("\n"+'-'*100)
    print_ln("当前查询点 (索引 %s) 为 (%s)", q_idx, querynode[q_idx].reveal())
    bruteforce_for_query_sort(q_idx)
   
print_ln('-'*50+'END'+'-'*50)